[{"title":"Mac下启动Tomcat","date":"2017-01-23T07:11:08.000Z","path":"2017/01/23/Start_Tomcat/","text":"一、安装Java官网下载jdk安装地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 二、下载启动Tomcat1.下载Tomcat，地址：http://tomcat.apache.org/download-80.cgimac下载zip和tar.gz都行，我下载的是zip 2.解压缩之后直接拷贝到资源库中，为方便管理解压后文件夹名称为Tomcat，具体位置如下: 打开终端，输入以下命令1$ sudo sh /Library/Tomcat/bin/startup.sh 浏览器中输入localhost:8080，就可以看到一下效果: 三、安装过程中遇到的问题 1.执行启动命令时提示No such file or directory错误 需要执行以下命令赋予权限：1$ sudo chmod 755 /Library/Tomcat/bin/*.sh 2.执行启动命令时提示JAVA_HOME或JRE_HOME错误 修改用户全局变量：打开用户根目录下的.bash_profile文件添加如下两行，如图12export JAVA_HOME=`/usr/libexec/java_home`export JRE_HOME=$JAVA_HOME/jre 更新配置的环境变量：1$ source .bash_profile 也可以修改Tomcat/bin/setclasspath.sh环境变量","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"layer层动画","date":"2017-01-17T10:43:57.000Z","path":"2017/01/17/UI_Animation/","text":"一、系统自带动画效果123456789101112// layer层动画CATransition *transition = [CATransition animation];// 动画效果transition.type = @\"rippleEffect\";// 动画方向[transition setSubtype: kCATransitionFromBottom];// 动画时长[transition setDuration:1];// 动画重复次数, NSIntegerMax 无限次数[transition setRepeatCount:NSIntegerMax];// 给myView的layer属性添加一个动画效果[self.myView.layer addAnimation:transition forKey:@\"transition\"]; 附type值列表 type 效果 “cube” 立方体翻滚效果 “moveIn” 新视图移到旧视图上面 “reveal” 显露效果(将旧视图移开,显示下面的新视图) “fade” 交叉淡化过渡(不支持过渡方向) (默认为此效果) “pageCurl” 向上翻一页 “pageUnCurl” 向下翻一页 “suckEffect” 收缩效果，类似系统最小化窗口时的神奇效果(不支持过渡方向) “rippleEffect” 滴水效果,(不支持过渡方向) “oglFlip” 上下左右翻转效果 “rotate” 旋转效果 “push” “cameraIrisHollowOpen” 相机镜头打开效果(不支持过渡方向) “cameraIrisHollowClose” 相机镜头关上效果(不支持过渡方向) 二、CAPropertyAnimation 属性动画 CAPropertyAnimation 它是一个抽象类, 我们用它的两个子类来实现属性动画, 也是layer层动画 1.scale12345678910111213// path参数填写的是transform的属性 scale是改变view的缩放比例CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];// 时长[basicAnimation setDuration:1];// 次数[basicAnimation setRepeatCount:NSIntegerMax];// 设置缩放起始值basicAnimation.fromValue = [NSNumber numberWithInt:0];// 设置缩放结束值basicAnimation.toValue = [NSNumber numberWithInt:1.5];[self.myImageView.layer addAnimation:basicAnimation forKey:@\"basicAnimation\"];// 设置动画结束后是否恢复到原来的状态basicAnimation.autoreverses = YES; 2.rotation12345678// 设置旋转动画效果 ratation旋转CABasicAnimation *basicAnimation2 = [CABasicAnimation animationWithKeyPath:@\"transform.rotation\"];basicAnimation2.fromValue = [NSNumber numberWithInt:0];basicAnimation2.toValue = [NSNumber numberWithInt:M_PI * 100];[basicAnimation2 setDuration:200];[basicAnimation2 setRepeatCount:NSIntegerMax];[basicAnimation2 setAutoreverses:YES];[self.myImageView.layer addAnimation:basicAnimation2 forKey:@\"rotatiom\"]; 三、关键帧动画 关键帧动画, 实现是通过一帧一帧的点或者角度等, 来实现整个动画过程 123456789101112131415161718192021222324252627// path的值为路径位置CAKeyframeAnimation *keyFrameAnimation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];// 创建一个路径, 用来记录移动的每一帧CGMutablePathRef path = CGPathCreateMutable();// 指定移动的起始点坐标CGPathMoveToPoint(path, NULL, self.myImageView.center.x, self.myImageView.center.y);// 设置移动轨迹 也就是每一帧 (坐标)// 参数1.为移动路径// 参数2.备用参数, 设为NULL// 参数3.移动的x坐标// 参数4.移动的y坐标CGPathAddLineToPoint(path, NULL, 100, 100);CGPathAddLineToPoint(path, NULL, 10, 10);CGPathAddLineToPoint(path, NULL, 200, 300);CGPathAddLineToPoint(path, NULL, 300, 500); // 给视图指定一条曲线路径CGPathAddCurveToPoint(path, NULL, 200, 200, 100, 120, 40, 60);CGPathAddCurveToPoint(path, NULL, 80, 10, 20, 100, 300, 100);CGPathAddCurveToPoint(path, NULL, 30, 60, 80, 100, 200, 300);CGPathAddCurveToPoint(path, NULL, 50, 90, 110, 10, self.myImageView.center.x, self.myImageView.center.y); // 将路径添加到关键帧动画对象中[keyFrameAnimation setPath:path];[keyFrameAnimation setDuration:5];[keyFrameAnimation setRepeatCount:NSIntegerMax];[self.myView.layer addAnimation:keyFrameAnimation forKey:@\"keyFrameAnimation\"];","tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/tags/移动开发/"}]},{"title":"免越狱版iOS抢红包插件","date":"2017-01-12T08:20:08.000Z","path":"2017/01/12/免越狱版iOS抢红包插件/","text":"最近在看《iOS应用逆向工程》这本书，就在github上找了些关于免越狱微信抢红包的资料，结合着各位大神的教程，于是就开始了一步步尝试，此篇主要的目的是为了防止自己忘记。 原理虽然这里并不深入讲解，但是最基本的原理我们还是要理解的，因为后面所做的工作，都是基于这个原理来进行开发的。越狱机器之所以能使用 tweak，主要是因为在越狱的时候，手机里就安装了 mobilesubstrate 这个库，这个库的作用就是能在程序运行的时候动态加载我们自己写的 dylib 动态运行库。而由于非越狱手机系统里面是没有这个库的，所以我们需要直接将这个库打包进 ipa 当中，使用它的 API 实现注入。 关于注入的原理，可以参考这篇文章：移动App入侵与逆向破解技术－iOS篇。 获取砸壳版本的微信 ipa 因为在 AppStore 上面下载得到的应用都是经过加密的，可以执行文件上已经被加过一层壳，所以我们需要先拿到砸过壳版本的微信应用。 有两种方法： 直接在爱思助手下载 使用 Clutch 对越狱手机上应用进行砸壳由于手上没有越狱的设备，于是选择了第一种，在爱思助手上下载了微信6.5.3版本。(尝试过使用pp助手下载越狱版微信，但是发现还是被加密了) 确认app是否加密第一步，解压获得二进制文件，并查看包含的架构1234567$ unzip WeChat.ipa -d wechat...$ cd wechat/Payload/WeChat.app/$ file WechatWechat: Mach-O universal binary with 2 architecturesWechat (for architecture armv7): Mach-O executable armWechat (for architecture arm64): Mach-O 64-bit executable 第二步，通过 otool -l 输出 app load commands ，然后查看 cryptid 标志位的值是否为 0（0表示未加密，1表示已加密）1234567$ otool -l Wechat | grep cryptcryptoff 16384cryptsize 38748160cryptid 0cryptoff 16384cryptsize 41467904cryptid 0 准备 dylib 动态链接库这步就很简单了，我选择到buginux的WeChatRedEnvelop上把源码 clone 下来，然后执行 make 命令，就能拿到 dylib 文件了。12345678910$ git clone https://github.com/buginux/WeChatRedEnvelop.git$ cd WeChatRedEnvelop$ make # &gt; Making all for tweak WeChatRedEnvelop…# ==&gt; Preprocessing Tweak.xm…# ==&gt; Compiling Tweak.xm (armv7)…# ==&gt; Compiling XGPayingViewController.m (armv7)…# ...# ==&gt; Signing WeChatRedEnvelop…$ cp .theos/obj/debug/WeChatRedEnvelop.dylib ~/Desktop # 注意是 .theos 目录，这是个隐藏目录 将生成的 dylib 文件拷贝到桌面，跟刚刚砸过壳的微信应用放到一个目录层级。 检查依赖项使用 macOS 自带的 otool 工具就可以进行依赖项检查：12345678910111213141516171819$ otool -L WeChatRedEnvelop.dylibWeChatRedEnvelop.dylib (architecture armv7):/Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.1.0)/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.0.0)/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.5.2)/usr/lib/libsubstrate.dylib (compatibility version 0.0.0, current version 0.0.0)/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)WeChatRedEnvelop.dylib (architecture arm64):/Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.1.0)/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.0.0)/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.5.2)/usr/lib/libsubstrate.dylib (compatibility version 0.0.0, current version 0.0.0)/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0) 可以看到除了 substrate 库，其它依赖的都是系统自带的库。我们将 libsubstrate.dylib 拷出，使用 install_name_tool 命令修改动态库的路径，指向 app 二进制文件的同级目录。 1234如果你的系统中不是 /usr/lib/libsubstrate.dylib 而是 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate的话下载链接: https://pan.baidu.com/s/1qXBqHSo 密码: efvy然后执行：$ install_name_tool -change /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate @loader_path/libsubstrate.dylib WeChatRedEnvelop.dylib 可以看到 libsubstrate.dylib 的路径已经变更了。 123456789101112131415161718192021$ scp root@&lt;your.device.ip&gt;:/usr/lib/libsubstrate.dylib ~/Desktop$ install_name_tool -change /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate @loader_path/libsubstrate.dylib WeChatRedEnvelop.dylib$ otool -L WeChatRedEnvelop.dylibWeChatRedEnvelop.dylib (architecture armv7):/Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.1.0)/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.0.0)/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.5.2)@loader_path/libsubstrate.dylib (compatibility version 0.0.0, current version 0.0.0)/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)WeChatRedEnvelop.dylib (architecture arm64):/Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.1.0)/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.0.0)/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.5.2)@loader_path/libsubstrate.dylib (compatibility version 0.0.0, current version 0.0.0)/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0) 将动态链接库注入二进制文件中接下来，就需要将我们的库注入到微信的二进制文件中，可以使用开源的 optool 工具。编译安装 optool 工具：123$ git clone --recursive https://github.com/alexzielenski/optool.git$ cd optool$ xcodebuild -project optool.xcodeproj -configuration Release ARCHS=\"i386 x86_64\" build 将砸壳过的 ipa 文件解压，然后将 libsubstrate.dylib 与 WeChatRedEnvelop.dylib 拷贝到解压后的 WeChat.app 目录下。123$ cd ~/Desktop$ unzip wechat.ipa -d wechat$ cp libsubstrate.dylib WeChatRedEnvelop.dylib wechat/Payload/WeChat.app 使用 optool 把 WeChatRedEnvelop.dylib 注入到二进制文件中：1$ /path/to/optool install -c load -p \"@executable_path/WeChatRedEnvelop.dylib\" -t wechat/Payload/WeChat.app/WeChat 在开始打包之前，请先将 WeChat.app 里面的 Watch 目录删除，这个目录是跟 Watch 有关的，如果不删除的话，会导致后继的安装步骤出问题。出现 A WatchKit app within this app is not a valid bundle 的错误。 打包并重签名打包 ipa 与重签名可以直接使用图形化工具 ios-app-signer 来完成。 这个工具可以自动加载出本机的证书以及 Provisioning Profile 文件，使用起来十分方便，当然也可以手动选择证书文件。如果是使用个人开发者证书，需要先将设备的 UUID 加到 Provisioning Profile 中。1如果是使用个人开发者证书，需要先将设备的 UUID 加到 Provisioning Profile 中。 我这里是直接从一个 archive 过的应用中提取 embedded.mobileprovision 文件，并在 Provisioning Profile 一栏中选择 Choose Custom File 使用这个文件。点击 start 后，指定保存路径，iOS App Signer 就会帮你搞定所有事情。 安装安装ideviceinstaller1安装ipa包用的，也可以通过itool之类的工具，不过ideviceinstaller可以看到安装过程的过程，方便我们找到出错原因。 执行命令1brew install ideviceinstaller 如果提示brew命令找不到，那就是你的Mac还没有安装Homebrew常见的报错信息：1ERROR: Could not connect to lockdownd, error code -5 这个时候只要重新安装libimobiledevice就可以了（因为ideviceinstaller依赖很多其他插件）执行下面的命令：12$ brew uninstall libimobiledevice$ brew install --HEAD libimobiledevice 连上你的手机执行下面的命令查看ideviceinstaller是否连接上手机：1$ ideviceinfo 如果打印出一大堆手机的信息表示连接成功可以安装ipa包，如果不成功请根据错误提示进行调整。执行下面的命令进行安装：123456789101112131415161718$ ideviceinstaller -i WeChat.ipa WARNING: could not locate iTunesMetadata.plist in archive!WARNING: could not locate Payload/WeChat.app/SC_Info/WeChat.sinf in archive!Copying 'WeChat.ipa' to device... DONE.Installing 'com.xxxxxxxxxxxx'- CreatingStagingDirectory (5%)- ExtractingPackage (15%)- InspectingPackage (20%)- TakingInstallLock (20%)- PreflightingApplication (30%)- InstallingEmbeddedProfile (30%)- VerifyingApplication (40%)- CreatingContainer (50%)- InstallingApplication (60%)- PostflightingApplication (70%)- SandboxingApplication (80%)- GeneratingApplicationMap (90%)- Complete 效果","tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/tags/移动开发/"}]},{"title":"mac下php安装mcrypt扩展","date":"2016-11-25T01:45:11.000Z","path":"2016/11/25/mac下php安装mcrypt扩展/","text":"MCrypt是一个功能强大的加密算法扩展库，它包括有22种算法。1：下载并解压mcrypt-2.6.8.tar.bz2。（2.6.8为版本号，可以自行选择，但是注意后边步骤要与下载的版本号一致。）2：在终端执行命令（注意如下命令需要安装xcode支持）：1234cd ~/Downloads/mcrypt-2.5.8./configure --disable-posix-threads --enable-staticmakesudo make install 或者使用homebrew安装 1brew install mcrypt 3：下载并解压php源码，根据自己情况选择对应版本。(注意以下命令中php的版本)在终端执行命令：（如果出错请看后边） 123456cd ~/Downloads/php-5.5.14/ext/mcryptphpize./configuremakecd modulessudo cp mcrypt.so /usr/lib/php/extensions/no-debug-non-zts-20121212/ （cd modules后当出现12Build complete.Don&apos;t forget to run &apos;make test&apos;. 表示安装成功。） 4：打开php.ini1sudo vi /etc/php.ini 添加如下代码：（注意no-debug-non-zts-20121212版本号，如果不清楚可以前往/usr/lib/php/extensions/查看） 1extension=/usr/lib/php/extensions/no-debug-non-zts-20121212/mcrypt.so *如果phpize出现如下错误： 123456789grep: /usr/include/php/main/php.h: No such file or directorygrep: /usr/include/php/Zend/zend_modules.h: No such file or directorygrep: /usr/include/php/Zend/zend_extensions.h: No such file or directoryConfiguring for:PHP Api Version:Zend Module Api No:Zend Extension Api No:Cannot find autoconf. Please check your autoconf installation and the$PHP_AUTOCONF environment variable. Then, rerun this script. 表示需要安装autoconf*如果make出现如下错误： 1/ext/mcrypt/mcrypt.c:25:10: fatal error: &apos;php.h&apos; file not found 执行如下命令即可： 1sudo ln -s /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include /usr/include *注意MacOSX10.10.sdk修改为自己系统的版本号","tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"Swift语法速记(转)","date":"2016-06-23T01:45:11.000Z","path":"2016/06/23/Switf语法速记/","text":"(一)类型常见类型123456789101112131415161718192021222324252627282930313233343536Int,String,Double,struct,enum,class,tuple//typle 元组类型//声明let someTuple:(Int,Int) = (10,23)//元组可以设置名称var person = (name:\"liuyw\",age:30)//取值方式1person.0person.1//取值方式2person.ageperson.name//取值方式3var (personName,personAge) = personpersonNamepersonAgesomeTuple.0或者tuple.1//typealias//类型的别名关键字//函数类型func//可选类型var num:Int? = nilvar num1:Optional&lt;Int&gt; = nil//隐式解析可选var num:Int!var num1:ImplicitlyUnwrappedOptional&lt;Int&gt;//协议合成类型var someProtocol:protocol&lt;protocol1,protocol2&gt; Array1234567891011121314151617181920212223242526272829//声明var array1:[String] = [\"0\",\"1\",\"2\",\"3\"]var array = [String]()//修改值array1 += [\"4\",\"5\"]array1[1...3] = [\"a\",\"b\",\"c\",\"d\",\"e\"]//array1.append//array1.removeAtIndex(&lt;index:Int Int&gt;)//array1.insert(&lt;newElement:Element&gt;, atIndex:&lt;Int&gt;)//获取值print(array1)print(array1[0])print(array1.last)print(array1.first)var str:String = \"\"//遍历for item:String in array1&#123; &#125;for bgen in array1.enumerate()&#123; print(\"元素下标:\\(bgen.0) 元素值:\\(bgen.1)\")&#125; dictionary12345678910111213141516171819 //声明var dic:Dictionary&lt;String,String&gt; = [\"name\":\"liu\",\"age\":\"30\"]var dic1 = Dictionary&lt;String,String&gt;()//修改值dic[\"name\"] = \"liuyanwei\"dic[\"name1\"] = \"liuyanwei1\"dic.updateValue(\"liuyw\", forKey: \"name\")//返回原值dic1.indexForKey(\"name1\")dic.removeValueForKey(\"name\")//获取值dic[\"name\"]//字典的循环for (key,value) in dictionary&#123; println(\"key is: \\(key) value is : \\(value)\");&#125; 枚举enum1234567891011121314151617181920//整形的枚举enum Sharp:Int&#123; case Rect=1,Circle,Star //switch中的选项可以用.表示 func desc()-&gt;String&#123; switch self&#123; case .Rect: return \"this is rect\" case .Circle: return \"this is circle\" case .Star: return \"this is star\" &#125; &#125;&#125;//enum的值Sharp.RawValue(1)//调用枚举的方法Sharp.Rect.desc() ##结构struct 12345678910111213141516//结构//结构和类的最重要的区别就是架构是传值，类是传引用struct Sharp&#123; //属性 var width:Int var height:Int //方法 func area()-&gt;Int&#123; return self.width*self.height; &#125; //允许修改属性的方法前缀 mutating mutating func zoomIn() &#123; self.width += 100 self.height += 100 &#125;&#125; ##协议 12345678910111213141516171819//可以被class，struct，enum实现protocol Sharp&#123; //属性 var width:String&#123;get&#125; var heiht:String&#123;get set&#125; //方法 func area()-&gt;Int &#125;//swift 可选和必选协议//只能被class实现，无法给struct和enum实现@objc protocol OptionalProtocol &#123; //可选协议 optional func optionalMethod() //必选协议 func necessaryMethod()&#125; ##对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Card: NSObject &#123; &#125;class Person: NSObject &#123; //私有对象 private var _name:String? var gender:String var gender1:String? //arc /* weak 用于可空对象，unowned用于非空对象 weak 调用被释放的对象会返回nil，unowned 调用被释放的对象会出异常 建议 如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak */ weak var bastFriend:Person? unowned var identityCard:Card //构造函数 init(name: String) &#123; gender = \"male\" identityCard = Card() super.init() //初始化。。。 self.name = name &#125; //便利构造函数 convenience init(name:String,gender:String) &#123; self.init(name:name) self.gender = gender &#125; //析构函数 deinit&#123; &#125; //属性 var name:String&#123; get&#123; return _name! &#125; set&#123; _name = newValue; &#125; //可以自定newValue的名称 //set(newName)&#123; // _gender = newName //&#125; &#125; //观察者模式的属性 //newValue 和 oldValue var age:Int = 0&#123; willSet&#123;&#125; didSet&#123;&#125; &#125; //方法 func sayName()&#123; print(\"hello name\") &#125; //静态方法 static func say()&#123; print(\"hello\") &#125; //类方法 class func say1()&#123; print(\"hello1\") &#125; //方法重载 override func copy() -&gt; AnyObject &#123; return \"\" &#125; //懒属性 //两种方式，方法加载和闭包加载 lazy var friends:[String] = self.findfriends() func findfriends()-&gt;[String]&#123; return [\"bob\",\"bill\",\"jobs\"] &#125; lazy var bastFirends:String = &#123; print(\" print bastFirends\") return \"liuyanwei\" &#125;() //调用 //NSLog(\"bastFirends:%@ and friends is:[%@] \",p.bastFirends,p.friends) //下标脚本 subscript(name:String)-&gt;String&#123; get&#123; return self.name &#125; set&#123; self.name = newValue; &#125; &#125; &#125; #（二）语法 ##流程控制 ###if语句 12345//判断是Option类是否有值if let theStr = str2 &#123; print(\"ture\")&#125; ###switch 123456789101112131415161718192021222324252627282930313233343536373839404142434445//switch 数字区间var condition1 = 888_888_888;switch condition1&#123; case -999_999...38: print(\"case1\"); case 40...88: print(\"case2\"); case 100...188: print(\"case3\"); case 200...999_999_999_999: print(\"case3\"); default:break;&#125;//switch 元组var condition2 = (100,88);switch condition2&#123; case (-99999...0,-99999...0),(40...88,0..&lt;100): print(\"case1\")//匹配多个条件case let (_,y): print(y); fallthrough // 值绑定,fallthrough 坠落下一个条件 case (_,0...100): print(\"case3\");// “_” 匹配所有 default:break;&#125;//switch 值绑定和where语句var condition3 = 100switch condition3&#123; case let i where i&lt;50 :print(\"case1\") case let i where i&lt;120 &amp;&amp; i&gt;50 :print(\"case2\") default :break;&#125;//switch 枚举enum BarCode&#123; case UPCA(Int,Int,Int) case QRCode(String)&#125;var condition4 = BarCode.UPCA(10, 5, 2)switch condition4&#123; case let .UPCA(a,b,c): print(\"a:\\(a)|b:\\(b)|c:\\(c)\") case .QRCode: print(\"case:2\")// default: break&#125;//对option的判断let num: Int? = nilswitch num &#123; case nil: println(\"没值\") default: println(\"\\(num!)\")&#125; ##函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//无参数func hello()&#123;&#125;//有参数func hello(name:String)&#123;&#125;//有参数和返回值func hello(name:String)-&gt;String&#123;&#125;//多个参数func hello(name:String,age:Int)&#123;&#125; //多个返回值func hello()-&gt;(String,Int)&#123; return (num1,num2,num3)&#125;//可变参数func hello(name:String...)&#123;&#125;//函数的嵌套func hello1()&#123; func hello2()&#123;&#125;&#125;//参数的默认值func hello1(msg:String = \"defaultMsg\")&#123;&#125;//返回值是函数func hello()-&gt;(String-&gt;String)&#123; func hello1(name:String)-&gt;String&#123;&#125; return hello1&#125;//参数是函数fun hello(msg:String,callback(Void-&gt;Void))&#123; callback()&#125;//函数参数是变量//若不声明var ，默认参数类型是let，就无法修改参数的值func hello(var msg:String)&#123; msg += \"hello\" print(msg)&#125;//函数参数的命名func hello(name name:String ,withAge age:Int)&#123;&#125;func hello1(name:String ,age:Int)&#123;&#125;//调用hello(name:&lt;String&gt;, withAge:&lt;Int&gt;)//默认的参数命名hello1(&lt;name:String String&gt;, age: &lt;Int&gt;)//指定的参数命名//匿名函数//&#123;&#125;可以作为匿名函数//例如调用上面的hello方法（参数是函数）hello(\"hi\", &#123; //dosthing &#125;)//有参数的匿名函数&#123; (msg:String)-&gt;String in return msg&#125;//泛型参数//输入输出参数的函数func myswap&lt;T&gt;(inout obj1:T,inout _ obj2:T)&#123; let temp:T = obj1 obj1 = obj2 obj2 = temp&#125; ##闭包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var array = [\"f\",\"a\",\"c\",\"d\",\"e\"]//完整写法//&#123; (参数:类型) in 执行方法 return 返回值&#125;array.sort(&#123; (s1:String,s2:String) -&gt; Bool in return s2 &gt; s1;&#125;)//省略参数类型和括号//&#123; 参数$1,$2 in 执行方法 return 返回值&#125;array.sort(&#123; s1,s2 -&gt; Bool in return s1 &gt; s2;&#125;)//省略参数类型和return关键字//&#123; 参数$1,$2 in 返回值&#125;array.sort(&#123; s1,s2 -&gt;Bool in s1 &lt; s2&#125;)//省略参数名array.sort(&#123; $1 &lt; $0&#125;)//尾随闭包array.sort()&#123; $1 &lt; $0&#125;//上面的几个其实只是匿名函数，不是真正的闭包。swift里面称他们是闭包，那就算是吧。真正的闭包是下面这个//闭包（closure）就是封闭的意思//闭包的概念,闭包概念有很多，我觉得比较好理解的的是松本行弘给的定义：将局部变量这一环境封闭起来的结构，叫做闭包func count()-&gt;(()-&gt;Int)&#123; var i = 0; return &#123; ()-&gt;Int in return ++i &#125;&#125;//测试使用var touch = count()touch()//1touch()//2touch()//3touch()//4 异常处理1234567891011121314151617181920212223242526enum AwfulError: ErrorType &#123; case Bad case Worse case Terrible&#125;func hello () throws&#123; throw AwfulError.Bad&#125;do &#123; try hello() print(\"final\")&#125;catch AwfulError.Bad &#123; print(\"Bad\")&#125;catch AwfulError.Worse &#123; print(\"Worse\")&#125;catch AwfulError.Terrible &#123; print(\"Terrible\")&#125;catch &#123; print(\"all error\")&#125; 断言1234assert(assert(&lt;condition:Bool Bool&gt;)assert(&lt;condition: Bool Bool&gt;, &lt;message: String String&gt;)assertionFailure()assertionFailure(&lt;message: String String&gt;) typealias 这个关键字可以给类，结构，枚举等增加别名，也常常用于合并协议后的别名typealias PetLike = protocol 编译标记//MARK ://MARK -:// TODO:// FIXME: Selector objc里面有@Selector(),在swift可以使用 let someMethod = Selector(“someMethodName”)得到。大多数情况无需这样 12345678910111213func callMe() &#123; NSLog(\"this is callMe\")&#125;func callMeWithParam(timer:NSTimer) &#123; NSLog(\"this is callMeWithParam,prarm is :\\(timer.userInfo as! String)\")&#125; //无参数NSTimer.scheduledTimerWithTimeInterval(2, target:self, selector:\"callMe\", userInfo: nil, repeats: true)//带参数,不使用SelectorNSTimer.scheduledTimerWithTimeInterval(2, target:self, selector: \"callMeWithParam:\", userInfo: \"i'm prarm\", repeats: true) 扩展12345extension Person&#123; func anotherHello()&#123; NSLog(\"another hello\") &#125;&#125; #（三）高级 ##柯里化 (Currying) 柯里化是一种量产类似方法的好办法，可以通过柯里化一个方法模板来避免写出很多重复代码 12345func addTwoNumbers(a: Int)(num: Int) -&gt; Int &#123; return a + num&#125;let addToFour = addTwoNumbers(4) // addToFour 是一个 Int -&gt; Intlet result = addToFour(num: 6) // result = 10 封装局部变量 封装局部变量可以减少变量之间的冲突 12345var str:String = &#123; //局部变量被封装 let str1 = \"hello\",str2 = \"world\" return \"\\(str1) \\(str2) !\"&#125;() 方法调用的另一种方式123456789101112131415class Person &#123; func hello(name:String) -&gt; String&#123; return \"hello \\(name)\" &#125;&#125;let person = Person()//常规方法调用person.hello(\"liuyanwei\")//利用方法名调用let funcOnPerson = Person.hellofuncOnPerson(person)(\"liuyanwei\") ##swift单例标准写法123456private let sharedInstance = MyManager()class MyManager &#123; class var sharedManager : MyManager &#123; return sharedInstance &#125;&#125;","tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/tags/移动开发/"}]},{"title":"第一篇博客","date":"2016-06-17T04:55:11.000Z","path":"2016/06/17/first-blog/","text":"拖延症晚期，终于把博客搭建起来了。以后就在这记录工作和学习中的一些技巧吧。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]